<!doctype html><html lang=en><meta charset=utf-8><meta name=viewport content="width=device-width, initial-scale=1.0, maximum-scale=1"><meta name=description content=""><meta name=author content="Zachary Snow"><title>The Blog of Zachary Snow</title><base href=../ ><link href="https://fonts.googleapis.com/css?family=Open+Sans" rel=stylesheet><link rel=stylesheet type=text/css href=css/style.css><link rel=alternate type=application/rss+xml title="The Blog of Zachary Snow" href=feed.rss><div class=wrap><header id=header><div class=container><div class=social><a href=http://twitter.com/smack0007 class=twitter title=Twitter><span class="fab fa-twitter"></span></a> <a href=http://github.com/smack0007 class=github title=Github><span class="fab fa-github"></span></a> <a href=feed.rss class=rss title=RSS><span class="fas fa-rss"></span></a></div><h1><a href=index.html title=Home>The Blog of Zachary Snow</a></h1></div></header><aside id=sidebar><nav><a href=index.html class=sidebar-nav-item>Home</a> <a href=about.html class=sidebar-nav-item>About</a></nav></aside><div id=hamburger onclick=toggleHamburger(this)><div class=bar1></div><div class=bar2></div><div class=bar3></div></div><script>function toggleHamburger(n){n.classList.toggle("active");document.getElementById("sidebar").classList.toggle("active")}</script><main class=container><div class=posts><div class=post><h2><a href=blog/2010/csharp-extension-methods-in-your-own-library.html>C# Extension Methods in your own Library</a></h2><div class=meta><span class=date><span class="fas fa-calendar-alt"></span>March 08, 2010</span> <span class=category><span class="fas fa-folder"></span>.NET</span> <span class=tags><span class="fas fa-tags"></span>C#, Extension Methods</span></div><div class=content><p>Normally I use extension methods in C# to extend a library that I did not write and therefore I have no control over. There are situations where it makes sense to use extension methods for a library that you yourself are writing.<p>For example, when you have interfaces in your library. You want to keep the number of methods in that interface as low as possible so that classes implementing the interface don't have to do a lot of heavy lifting. This means cutting out methods in an interface that are for the most part just syntactic sugar for another method in the interface.
<pre><code class=language-c#>

<span style=color:#00f>public</span> <span style=color:#00f>interface</span> IServiceContainer
{
    <span style=color:#00f>void</span> AddService(Type type, Object provider);
    <span style=color:#00f>object</span> GetService(Type type);
}

<span style=color:#00f>public</span> <span style=color:#00f>static</span> <span style=color:#00f>class</span> IServiceContainerExtensions
{
    <span style=color:#00f>public</span> <span style=color:#00f>static</span> <span style=color:#00f>void</span> AddService&amp;lt;T&amp;gt;(<span style=color:#00f>this</span> IServiceContainer services, <span style=color:#00f>object</span> provider)
    {
        services.AddService(<span style=color:#00f>typeof</span>(T), provider);
    }

    <span style=color:#00f>public</span> <span style=color:#00f>static</span> T GetService&amp;lt;T&amp;gt;(<span style=color:#00f>this</span> IServiceContainer services) <span style=color:#00f>where</span> T : <span style=color:#00f>class</span>
    {
        <span style=color:#00f>return</span> services.GetService(<span style=color:#00f>typeof</span>(T)) <span style=color:#00f>as</span> T;
    }

    <span style=color:#00f>public</span> <span style=color:#00f>static</span> T GetRequiredService&amp;lt;T&amp;gt;(<span style=color:#00f>this</span> IServiceContainer services) <span style=color:#00f>where</span> T : <span style=color:#00f>class</span>
    {
        T service = services.GetService(<span style=color:#00f>typeof</span>(T)) <span style=color:#00f>as</span> T;

        <span style=color:#00f>if</span>(service == <span style=color:#00f>null</span>)
            <span style=color:#00f>throw</span> <span style=color:#00f>new</span> ServiceNotFoundException(<span style=color:#00f>typeof</span>(T));

        <span style=color:#00f>return</span> service;
    }
}


</code></pre><p>All of the methods in IServiceContainerExtensions are just helper methods for method in IServiceContainer. By making them extension methods in our own library though, we've made the barrier to entry lower. Other people can implement the interface and in a sense "inherit" the helper methods as well.</div></div><div class=post><h2><a href=blog/2010/creating-and-consuming-services-in-your-xna-game.html>Creating and consuming services in your XNA Game</a></h2><div class=meta><span class=date><span class="fas fa-calendar-alt"></span>February 18, 2010</span> <span class=category><span class="fas fa-folder"></span>.NET</span> <span class=tags><span class="fas fa-tags"></span></span></div><div class=content><p>The <a href=http://msdn.microsoft.com/en-us/library/microsoft.xna.framework.gameservicecontainer.aspx>GameServiceContainer</a> implements the <a href=http://msdn.microsoft.com/en-us/library/system.iserviceprovider.aspx>IServiceProvider</a> interface and the MSDN documentation says about the IServiceProvider interface:<blockquote>Defines a mechanism for retrieving a service object; that is, an object that provides custom support to other objects.</blockquote><p>This article will "<em>attempt</em>" to describe how can you use the GameServiceContainer in your XNA game, in both your GameComponent(s) and your game's entity objects.</div></div><div class=post><h2><a href=blog/2010/changing-the-platformtarge-in-visual-c-express.html>Changing the PlatformTarget in Visual C# Express</a></h2><div class=meta><span class=date><span class="fas fa-calendar-alt"></span>January 18, 2010</span> <span class=category><span class="fas fa-folder"></span>.NET</span> <span class=tags><span class="fas fa-tags"></span>MSBuild</span></div><div class=content><p>Some project types in Visual C# Express (Empty Project) will not allow you to change the PlatformTarget from the UI. You can still change the target platform though by editing the .csproj file in a text editor. Close the project and open it up in your favorite text editor (I use <a href=http://notepad-plus.sourceforge.net/ >Notpad++</a>). The .csproj file is really just a XML file. You should see somewhere in the file something like:
<pre><code class=language-xml>
	<span style=color:#00f>&lt;</span><span style=color:#a31515>PropertyGroup</span> <span style=color:#f00>Condition</span><span style=color:#00f>=</span><span style=color:#000>"</span><span style=color:#00f> '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' </span><span style=color:#000>"</span><span style=color:#00f>></span>
		....
	<span style=color:#00f>&lt;/</span><span style=color:#a31515>PropertyGroup</span><span style=color:#00f>></span>
	<span style=color:#00f>&lt;</span><span style=color:#a31515>PropertyGroup</span> <span style=color:#f00>Condition</span><span style=color:#00f>=</span><span style=color:#000>"</span><span style=color:#00f> '$(Configuration)|$(Platform)' == 'Release|AnyCPU' </span><span style=color:#000>"</span><span style=color:#00f>></span>
		....
	<span style=color:#00f>&lt;/</span><span style=color:#a31515>PropertyGroup</span><span style=color:#00f>></span>

</code></pre><p>Inside the PropertyGroup elements, add the PlatformTarget element:
<pre><code class=language-xml>
	<span style=color:#00f>&lt;</span><span style=color:#a31515>PropertyGroup</span> <span style=color:#f00>Condition</span><span style=color:#00f>=</span><span style=color:#000>"</span><span style=color:#00f> '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' </span><span style=color:#000>"</span><span style=color:#00f>></span>
		....
		<span style=color:#00f>&lt;</span><span style=color:#a31515>PlatformTarget</span><span style=color:#00f>></span>x86<span style=color:#00f>&lt;/</span><span style=color:#a31515>PlatformTarget</span><span style=color:#00f>></span>
	<span style=color:#00f>&lt;/</span><span style=color:#a31515>PropertyGroup</span><span style=color:#00f>></span>
	<span style=color:#00f>&lt;</span><span style=color:#a31515>PropertyGroup</span> <span style=color:#f00>Condition</span><span style=color:#00f>=</span><span style=color:#000>"</span><span style=color:#00f> '$(Configuration)|$(Platform)' == 'Release|AnyCPU' </span><span style=color:#000>"</span><span style=color:#00f>></span>
		....
		<span style=color:#00f>&lt;</span><span style=color:#a31515>PlatformTarget</span><span style=color:#00f>></span>x86<span style=color:#00f>&lt;/</span><span style=color:#a31515>PlatformTarget</span><span style=color:#00f>></span>
	<span style=color:#00f>&lt;/</span><span style=color:#a31515>PropertyGroup</span><span style=color:#00f>></span>

</code></pre><p>Save the file and open your project back up. Your project's output should now target only x86.</div></div><div class=post><h2><a href=blog/2009/calculating-an-angle-from-a-vector2.html>Calculating an angle from a Vector2</a></h2><div class=meta><span class=date><span class="fas fa-calendar-alt"></span>February 28, 2009</span> <span class=category><span class="fas fa-folder"></span>.NET</span> <span class=tags><span class="fas fa-tags"></span>Vectors, Xna</span></div><div class=content><p>When you need to calculate an angle from a Vector2 structure, you can use this piece of code:
<pre><code class=language-c#>
<span style=color:#00f>public</span> <span style=color:#00f>static</span> <span style=color:#00f>class</span> Vector2Helper
{
	<span style=color:#00f>public</span> <span style=color:#00f>static</span> <span style=color:#00f>float</span> CalculateAngle(Vector2 v)
	{
		<span style=color:#00f>float</span> angle = <span>0</span>.0f;

		<span style=color:#00f>if</span>(v != Vector2.Zero)
		{
			v.Normalize();

			angle = (<span style=color:#00f>float</span>)Math.Acos(v.Y);

			<span style=color:#00f>if</span>(v.X &amp;lt; <span>0</span>.0f)
			angle = -angle;
		}

		<span style=color:#00f>return</span> angle;
	}
}

</code></pre><p>I used this to calculate an angle from the Vector2 of the Left Stick.<p>The original credit for this source code comes from <a href=http://xnagamer.spaces.live.com/blog/cns!EC20BAAE6808B682!139.entry>here</a>.</div></div><div class=post><h2><a href=blog/2009/the-game-show-host-problem-aka-the-monty-hall-problem.html>The Game Show Host Problem, aka The Monty Hall Problem</a></h2><div class=meta><span class=date><span class="fas fa-calendar-alt"></span>February 12, 2009</span> <span class=category><span class="fas fa-folder"></span>Random</span> <span class=tags><span class="fas fa-tags"></span></span></div><div class=content><p><em>NOTE: This is a repost from my old blog.</em><p>So, me and my girlfriend went to see 21 last night and in the movie they make mention of The Game Show Host problem, aka The Monty Hall Problem.<p>The jist of the problem is this: You are on a game show. The host presents you with 3 doors, 1 of which has a car behind it, the other 2 have goats. The game show host tells you to pick a door. You do so, at which point the game show host opens up a door to show you a goat behind the door and then asks you if you would like to switch your choice to the other closed door. The question is then, should you switch your choice?<p>The correct answer is yes. More on why after the jump.<p>I won’t go too far into detail about why you should switch your answer, I’ll leave that to Wikipedia. Some things to note that may not be obvious: 1) The game show host will always open a door that is not the correct door 2) He will never open your door. These are the keys to this problem. By switching, you will win a prize 2/3 of the time as opposed to only winning 1/3 of the time if you do not.<p>Many people will argue that once the game show host opens the door with the goat behind it that there is now a 50% chance of you picking the right door by either staying with your door or switching. This is simply not true. Each door still only has 33.3% chance of being the door with the car behind it. The thing is though, once you pick your door, the game show host then eliminates a door based on 2 criteria: 1) The door is not the one with the prize behind it 2) The door is not yours. Due to these criteria, the odds of the correct door do not change for the door that you have picked, but rather change for the doors that you have not picked. The 2 doors not chosen by you then in a sense combine into one option and they together have a probability of 66.7%.<p>The Wikipedia article explains in much more mathematical detail why it is better to switch. I suggest you look there if I have done nothing but confuse you. This is simple strategy and probability. Knowing exactly how the game works can make you alot better at it.</div></div></div><div class=clear></div><div class=pagination><a href=blog\page11.html class="pagination-item older">Older</a> <a href=blog\page9.html class="pagination-item newer">Newer</a></div></main></div>